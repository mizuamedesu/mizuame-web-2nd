---
---

<style>
  .scene-container {
    position: relative;
    width: 100%;
    height: 100vh;
  }

  .vrm-container {
    width: 100%;
    height: 100vh;
    transition: position 0.3s ease;
  }

  .vrm-container.fixed {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 1;
  }

  .vrm-container.normal {
    position: relative;
  }

  .virtual-scroll {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow-y: scroll;
    z-index: 2;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .virtual-scroll::-webkit-scrollbar {
    display: none;
  }

  .scroll-content {
    height: 200%;
    pointer-events: none;
  }
</style>

<div class="scene-container">
  <div id="vrm-container" class="vrm-container fixed"></div>
  <div class="virtual-scroll" id="virtual-scroll">
    <div class="scroll-content"></div>
  </div>
</div>

<script>
  import * as THREE from "three";
  import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
  import { VRM, VRMLoaderPlugin } from "@pixiv/three-vrm";
  import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
  import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
  import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
  import type { GLTF } from "three/examples/jsm/loaders/GLTFLoader.js";

  // ▼ VRMA 用の追加インポート
  import {
    createVRMAnimationClip,
    VRMAnimationLoaderPlugin,
  } from "@pixiv/three-vrm-animation";

  // グリッチシェーダーの定義
  const GlitchShader = {
    uniforms: {
      tDiffuse: { value: null },
      time: { value: 0 },
      amount: { value: 0.0 },
      seed: { value: 0.02 },
      seed_x: { value: 0.02 },
      seed_y: { value: 0.02 },
      distortion_x: { value: 0.5 },
      distortion_y: { value: 0.6 },
      col_s: { value: 0.05 }
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D tDiffuse;
      uniform float time;
      uniform float amount;
      uniform float seed;
      uniform float seed_x;
      uniform float seed_y;
      uniform float distortion_x;
      uniform float distortion_y;
      uniform float col_s;
      varying vec2 vUv;

      float rand(vec2 co) {
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }

      void main() {
        if(amount == 0.0){
          gl_FragColor = texture2D(tDiffuse, vUv);
          return;
        }

        vec2 p = vUv;
        float xs = floor(gl_FragCoord.x / 0.5);
        float ys = floor(gl_FragCoord.y / 0.5);
        
        if(rand(vec2(xs * seed, ys * seed * 50.0)) > 0.9){
          p.y = p.y + (rand(vec2(xs * seed * 50.0, ys * seed * 50.0)) - 0.5) * 0.1 * amount;
        }

        if(rand(vec2(xs * seed, ys * seed * 50.0)) > 0.9){
          p.x = p.x + (rand(vec2(xs * seed * 50.0, ys * seed * 50.0)) - 0.5) * 0.1 * amount;
        }

        vec4 c = texture2D(tDiffuse, p);
        vec4 c_r = texture2D(tDiffuse, vec2(p.x + amount * seed_x, p.y + amount * seed_y * 0.5));
        vec4 c_g = texture2D(tDiffuse, vec2(p.x + amount * seed_x * 0.966, p.y + amount * seed_y));
        vec4 c_b = texture2D(tDiffuse, vec2(p.x + amount * seed_x * 1.033, p.y + amount * seed_y * 1.5));

        vec4 normal;
        normal.r = c.r * (1.0 - amount) + c_r.r * amount;
        normal.g = c.g * (1.0 - amount) + c_g.g * amount;
        normal.b = c.b * (1.0 - amount) + c_b.b * amount;
        normal.a = c.a;

        gl_FragColor = normal;
      }
    `
  };

  interface SceneSetup {
    scene: THREE.Scene;
    camera: THREE.PerspectiveCamera;
    renderer: THREE.WebGLRenderer;
    composer: EffectComposer;
    glitchPass: ShaderPass;
    directionalLight: THREE.DirectionalLight;
    ambientLight: THREE.AmbientLight;
  }

  // シーン初期化
  const initScene = (): SceneSetup => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(
      45.0,
      window.innerWidth / window.innerHeight,
      0.1,
      100.0
    );
    camera.position.set(0, 1.3, 0.7);
    camera.lookAt(0, 1.5, 0);

    const container = document.getElementById("vrm-container");
    if (!container) {
      throw new Error("Container element not found");
    }

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0xffffff, 1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const glitchPass = new ShaderPass(GlitchShader);
    composer.addPass(glitchPass);

    const directionalLight = new THREE.DirectionalLight(0xeeeeee, 1.0);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    const ambientLight = new THREE.AmbientLight(0xeeeeee, 0.5);
    scene.add(ambientLight);

    return {
      scene,
      camera,
      renderer,
      composer,
      glitchPass,
      directionalLight,
      ambientLight
    };
  };

  const main = async () => {
    const {
      scene,
      camera,
      renderer,
      composer,
      glitchPass,
      directionalLight,
      ambientLight
    } = initScene();

    glitchPass.uniforms.amount.value = 0.8;

    const virtualScroll = document.getElementById("virtual-scroll");
    if (!virtualScroll) {
      throw new Error("Virtual scroll element not found");
    }

    const vrmContainer = document.getElementById("vrm-container");
    if (!vrmContainer) {
      throw new Error("VRM container element not found");
    }

    let scrollPercent = 0;
    virtualScroll.addEventListener("scroll", () => {
      const maxScroll = virtualScroll.scrollHeight - virtualScroll.clientHeight;
      scrollPercent = Math.min(virtualScroll.scrollTop / maxScroll, 1);
      
      // スクロールが完了したら fixed を解除
      if (scrollPercent >= 0.99) {
        vrmContainer.classList.remove("fixed");
        vrmContainer.classList.add("normal");
      } else {
        vrmContainer.classList.remove("normal");
        vrmContainer.classList.add("fixed");
      }

      glitchPass.uniforms.amount.value = 0.2 + (1 - scrollPercent) * 0.6;
    });

    // ▼ GLTFLoader のセットアップ (VRM + VRMA 両方使えるようにプラグイン登録)
    const loader = new GLTFLoader();
    loader.register((parser) => new VRMLoaderPlugin(parser));
    loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

    let currentVrm: VRM | null = null;
    let currentMixer: THREE.AnimationMixer | null = null;

    // VRM 読み込み
    // （VRMA 読み込みはこの後に続けて行う）
    try {
      const gltf = await new Promise<GLTF>((resolve, reject) => {
        loader.load(
          "/models/demo.vrm",
          resolve,
          (progress) => console.log("Loading progress:", (progress.loaded / progress.total) * 100 + "%"),
          reject
        );
      });

      const vrm = gltf.userData.vrm as VRM;
      if (vrm) {
        currentVrm = vrm;
        scene.add(vrm.scene);

        vrm.scene.position.set(0, 0, 0);
        vrm.scene.rotation.y = Math.PI;

        // とりあえず表情テスト
        if (vrm.expressionManager) {
          vrm.expressionManager.setValue("blink", 1.0);
          vrm.expressionManager.update();
        }
      }
    } catch (error) {
      console.error("Error loading VRM model:", error);
    }

    // ▼ VRMA を読み込んで、アニメーションを適用
    //   VRM が読み込めている前提で実行 (async/awaitで順番保証)
    try {
      const gltf2 = await new Promise<GLTF>((resolve, reject) => {
        loader.load(
          "/animations/listen.vrma", // ここを実際のファイルパスに置き換える
          resolve,
          (progress) => console.log("Loading VRMA progress:", (progress.loaded / progress.total) * 100 + "%"),
          reject
        );
      });

      // .vrma ファイルでは userData.vrmAnimations に配列が入る
      const vrmAnimations = gltf2.userData.vrmAnimations;
      if (vrmAnimations && vrmAnimations.length > 0 && currentVrm) {
        // 最初のアニメーションを仮に使う例
        const vrma = vrmAnimations[0];

        // Mixer の作成
        currentMixer = new THREE.AnimationMixer(currentVrm.scene);

        // アニメーションクリップを生成
        const clip = createVRMAnimationClip(vrma, currentVrm);

        // ループなど調整したい場合は下記のように設定
        // clip.loop = THREE.LoopRepeat; // ループ再生したい場合
        // clip.clampWhenFinished = true;

        // 再生開始
        const action = currentMixer.clipAction(clip);
        action.play();

        console.log("VRMA animation loaded and playing");
      }
    } catch (error) {
      console.error("Error loading VRMA animation:", error);
    }

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // VRM の表情連動（スクロール連動）など
      if (currentVrm) {
        if (currentVrm.expressionManager) {
          currentVrm.expressionManager.setValue("blink", 1.0 - scrollPercent);
          currentVrm.expressionManager.update();
        }

        // ライト強度をスクロールに応じて変化
        directionalLight.intensity = 1.0 + scrollPercent * 0.8;
        ambientLight.intensity = 0.5 + scrollPercent * 0.4;

        // VRM のアップデート
        currentVrm.update(delta);
      }

      // ▼ VRMA 再生用ミキサー更新
      if (currentMixer) {
        currentMixer.update(delta);
      }

      // グリッチシェーダーの time を更新しつつレンダリング
      glitchPass.uniforms.time.value += delta;
      composer.render();
    }

    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  };

  document.addEventListener("DOMContentLoaded", main);
</script>

<style>
  .scene-container {
    position: relative;
    width: 100%;
    height: 100vh;
    /* 3Dモデルを表示するための土台 */
  }
</style>

<div class="three-canvas" id="vrm-container"></div>

<script>
  import * as THREE from "three";
  import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
  import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
  import { VRM, VRMLoaderPlugin } from "@pixiv/three-vrm";
  import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
  import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
  import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";

  // グリッチシェーダーの定義
  const GlitchShader = {
    uniforms: {
      tDiffuse: { value: null },
      time: { value: 0 },
      amount: { value: 0.0 },
      seed: { value: 0.02 },
      seed_x: { value: 0.02 },
      seed_y: { value: 0.02 },
      distortion_x: { value: 0.5 },
      distortion_y: { value: 0.6 },
      col_s: { value: 0.05 },
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float amount;
        uniform float seed;
        uniform float seed_x;
        uniform float seed_y;
        uniform float distortion_x;
        uniform float distortion_y;
        uniform float col_s;
        varying vec2 vUv;

        float rand(vec2 co) {
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        bool isInRectangle(vec2 p, vec2 center, vec2 size) {
            vec2 d = abs(p - center);
            return d.x < size.x && d.y < size.y;
        }

        void main() {
            if(amount == 0.0){
                gl_FragColor = texture2D(tDiffuse, vUv);
                return;
            }

            vec2 p = vUv;
            float xs = floor(gl_FragCoord.x / 0.5);
            float ys = floor(gl_FragCoord.y / 0.5);
            vec4 normal = texture2D(tDiffuse, p);

            if(rand(vec2(xs * seed, ys * seed * 50.0)) > 0.9){
                p.y = p.y + (rand(vec2(xs * seed * 50.0, ys * seed * 50.0)) - 0.5) * 0.1 * amount;
            }

            if(rand(vec2(xs * seed, ys * seed * 50.0)) > 0.9){
                p.x = p.x + (rand(vec2(xs * seed * 50.0, ys * seed * 50.0)) - 0.5) * 0.1 * amount;
            }

            // 静的な長方形マスクの定義（複数配置）
            bool inMask = false;
            
            // 長方形1
            inMask = inMask || isInRectangle(vUv, vec2(0.3, 0.4), vec2(0.15, 0.08));
            // 長方形2
            inMask = inMask || isInRectangle(vUv, vec2(0.7, 0.6), vec2(0.12, 0.15));
            // 長方形3
            inMask = inMask || isInRectangle(vUv, vec2(0.5, 0.2), vec2(0.08, 0.12));
            // 長方形4
            inMask = inMask || isInRectangle(vUv, vec2(0.2, 0.8), vec2(0.1, 0.06));
            // 長方形5
            inMask = inMask || isInRectangle(vUv, vec2(0.8, 0.3), vec2(0.06, 0.1));

            // 逆マスク処理（マスク部分以外を表示）
            if (!inMask) {
                normal = vec4(0.0, 0.0, 0.0, 1.0);  // マスク外を黒く
            }

            // RGBシフト
            vec4 c = texture2D(tDiffuse, p);
            vec4 c_r = texture2D(tDiffuse, vec2(p.x + amount * seed_x, p.y + amount * seed_y * 0.5));
            vec4 c_g = texture2D(tDiffuse, vec2(p.x + amount * seed_x * 0.966, p.y + amount * seed_y));
            vec4 c_b = texture2D(tDiffuse, vec2(p.x + amount * seed_x * 1.033, p.y + amount * seed_y * 1.5));
            
            normal.r = c.r * (1.0 - amount) + c_r.r * amount;
            normal.g = c.g * (1.0 - amount) + c_g.g * amount;
            normal.b = c.b * (1.0 - amount) + c_b.b * amount;

            gl_FragColor = normal;
        }
    `,
  };

  // シーンのセットアップ
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);

  const camera = new THREE.PerspectiveCamera(
    45.0,
    window.innerWidth / window.innerHeight,
    0.1,
    100.0
  );
  camera.position.set(0, 1.3, 0.7);
  camera.lookAt(0, 1.5, 0);

  const container = document.getElementById("vrm-container");
  if (!container) {
    throw new Error("Container element not found");
  }

  const renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true,
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0xffffff, );
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  // エフェクトコンポーザーのセットアップ
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  const glitchPass = new ShaderPass(GlitchShader);
  composer.addPass(glitchPass);

  // ライトのセットアップ
  const directionalLight = new THREE.DirectionalLight(0xeeeeee, 1.0);
  directionalLight.position.set(1, 1, 1);
  scene.add(directionalLight);

  const ambientLight = new THREE.AmbientLight(0xeeeeee, 0.5);
  scene.add(ambientLight);

  // スクロール量の追跡
  let scrollPercent = 0;

  // 初期状態でグリッチエフェクトを設定
  glitchPass.uniforms.amount.value = 0.8;

  window.addEventListener("scroll", () => {
    const maxScroll =
      document.documentElement.scrollHeight - window.innerHeight;
    scrollPercent = Math.min(window.scrollY / maxScroll, 1);

    // スクロールに応じてグリッチの強度を逆に変更（スクロールで弱く）
    // 初期値を0.8に、最小値を0.2に設定
    glitchPass.uniforms.amount.value = 0.2 + (1 - scrollPercent) * 0.6;
  });

  // VRMモデルのロード
  const loader = new GLTFLoader();
  loader.register((parser) => new VRMLoaderPlugin(parser));

  let currentVrm = null;

  loader.load(
    "/models/demo.vrm",
    async (gltf) => {
      const vrm = gltf.userData.vrm;
      if (vrm) {
        currentVrm = vrm;
        scene.add(vrm.scene);

        vrm.scene.position.set(0, 0, 0);
        vrm.scene.rotation.y = Math.PI;

        if (vrm.expressionManager) {
          vrm.expressionManager.setValue("blink", 1.0);
          vrm.expressionManager.update();
        }
      }
    },
    (progress) => {
      console.log(
        "Loading progress:",
        (progress.loaded / progress.total) * 100 + "%"
      );
    },
    (error) => {
      console.error("Error loading model:", error);
    }
  );

  // アニメーションループ
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();

    if (currentVrm) {
      if (currentVrm.expressionManager) {
        currentVrm.expressionManager.setValue("blink", 1.0 - scrollPercent);
        currentVrm.expressionManager.update();
      }

      directionalLight.intensity = 1.0 + scrollPercent * 0.8;
      ambientLight.intensity = 0.5 + scrollPercent * 0.4;

      currentVrm.update(delta);
    }

    // グリッチエフェクトの時間更新
    glitchPass.uniforms.time.value += delta;

    composer.render();
  }

  animate();

  // ウィンドウリサイズ対応
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  });

  
</script>

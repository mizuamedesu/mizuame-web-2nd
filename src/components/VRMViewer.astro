---
import AnimatedTextReveal from "../components/AnimatedTextReveal.astro";
---
  
<style>
  .scene-container {
    position: relative;
    width: 100%;
    height: 100vh;
  }

  .vrm-container {
    width: 100%;
    height: 100vh;
    transition: position 0.3s ease;
    z-index: 1; /* 基本の z-index を設定 */
  }

  .vrm-container.fixed {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 1;
  }

  .vrm-container.normal {
    position: relative;
    z-index: 1;
  }

  .virtual-scroll {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow-y: scroll;
    z-index: 2;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .virtual-scroll::-webkit-scrollbar {
    display: none;
  }

  .scroll-content {
    height: 200%;
    pointer-events: none;
  }

  /* Styles for AnimatedTextReveal */
  .animated-text {
    position: absolute; /* .scene-container に対して絶対配置 */
    top: 10%; /* vrm-container の上に表示する位置を調整 */
    left: 50%;
    transform: translateX(-50%);
    width: auto;
    text-align: center;
    display: none; /* 初期状態では非表示 */
    z-index: 3; /* vrm-container と virtual-scroll より上に表示 */
    pointer-events: none; /* 背景の要素と相互作用を維持 */
  }
</style>

<div class="scene-container">
  <div id="vrm-container" class="vrm-container fixed"></div>
  <div class="virtual-scroll" id="virtual-scroll" tabindex="-1">
    <div class="scroll-content"></div>
  </div>
  
  <!-- Animated Text Reveal Component -->
  <div id="animated-text" class="animated-text">
    <AnimatedTextReveal text="Hi" textSize="3rem" space="1rem" />
  </div>
</div>

<script>
  import * as THREE from "three";
  import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
  import { VRM, VRMLoaderPlugin } from "@pixiv/three-vrm";
  import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
  import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
  import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
  import type { GLTF } from "three/examples/jsm/loaders/GLTFLoader.js";

  // ▼ VRMA 用の追加インポート
  import {
    createVRMAnimationClip,
    VRMAnimationLoaderPlugin,
  } from "@pixiv/three-vrm-animation";

  // グリッチシェーダーの定義
  const GlitchShader = {
    uniforms: {
      tDiffuse: { value: null },
      time: { value: 0 },
      amount: { value: 0.0 },
      seed: { value: 0.02 },
      seed_x: { value: 0.02 },
      seed_y: { value: 0.02 },
      distortion_x: { value: 0.5 },
      distortion_y: { value: 0.6 },
      col_s: { value: 0.05 }
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D tDiffuse;
      uniform float time;
      uniform float amount;
      uniform float seed;
      uniform float seed_x;
      uniform float seed_y;
      uniform float distortion_x;
      uniform float distortion_y;
      uniform float col_s;
      varying vec2 vUv;

      float rand(vec2 co) {
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }

      void main() {
        if(amount == 0.0){
          gl_FragColor = texture2D(tDiffuse, vUv);
          return;
        }

        vec2 p = vUv;
        float xs = floor(gl_FragCoord.x / 0.5);
        float ys = floor(gl_FragCoord.y / 0.5);
        
        if(rand(vec2(xs * seed, ys * seed * 50.0)) > 0.9){
          p.y = p.y + (rand(vec2(xs * seed * 50.0, ys * seed * 50.0)) - 0.5) * 0.1 * amount;
        }

        if(rand(vec2(xs * seed, ys * seed * 50.0)) > 0.9){
          p.x = p.x + (rand(vec2(xs * seed * 50.0, ys * seed * 50.0)) - 0.5) * 0.1 * amount;
        }

        vec4 c = texture2D(tDiffuse, p);
        vec4 c_r = texture2D(tDiffuse, vec2(p.x + amount * seed_x, p.y + amount * seed_y * 0.5));
        vec4 c_g = texture2D(tDiffuse, vec2(p.x + amount * seed_x * 0.966, p.y + amount * seed_y));
        vec4 c_b = texture2D(tDiffuse, vec2(p.x + amount * seed_x * 1.033, p.y + amount * seed_y * 1.5));

        vec4 normal;
        normal.r = c.r * (1.0 - amount) + c_r.r * amount;
        normal.g = c.g * (1.0 - amount) + c_g.g * amount;
        normal.b = c.b * (1.0 - amount) + c_b.b * amount;
        normal.a = c.a;

        gl_FragColor = normal;
      }
    `
  };

  interface SceneSetup {
    scene: THREE.Scene;
    camera: THREE.PerspectiveCamera;
    renderer: THREE.WebGLRenderer;
    composer: EffectComposer;
    glitchPass: ShaderPass;
    directionalLight: THREE.DirectionalLight;
    ambientLight: THREE.AmbientLight;
  }

  // シーン初期化
  const initScene = (): SceneSetup => {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(
      45.0,
      window.innerWidth / window.innerHeight,
      0.1,
      100.0
    );
    camera.position.set(0, 1.3, 0.8);
    camera.lookAt(0, 1.5, 0);

    const container = document.getElementById("vrm-container");
    if (!container) {
      throw new Error("Container element not found");
    }

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0xffffff, 1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const glitchPass = new ShaderPass(GlitchShader);
    composer.addPass(glitchPass);

    const directionalLight = new THREE.DirectionalLight(0xeeeeee, 1.0);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    const ambientLight = new THREE.AmbientLight(0xeeeeee, 0.5);
    scene.add(ambientLight);

    return {
      scene,
      camera,
      renderer,
      composer,
      glitchPass,
      directionalLight,
      ambientLight
    };
  };

  const main = async () => {
    const {
      scene,
      camera,
      renderer,
      composer,
      glitchPass,
      directionalLight,
      ambientLight
    } = initScene();

    // 基本のカメラ回転を保存
    const baseCameraRotation = new THREE.Euler().copy(camera.rotation);

    // 揺れの強さと速度を設定
    const shakeIntensity = 0.005; // 揺れの強さ
    const shakeSpeed = 5; // 揺れの速度

    glitchPass.uniforms.amount.value = 0.8;

    const virtualScroll = document.getElementById("virtual-scroll");
    if (!virtualScroll) {
      throw new Error("Virtual scroll element not found");
    }

    const vrmContainer = document.getElementById("vrm-container");
    if (!vrmContainer) {
      throw new Error("VRM container element not found");
    }

    const animatedText = document.getElementById("animated-text");
    if (!animatedText) {
      throw new Error("Animated text element not found");
    }

    let isScrollDisabled = false; // スクロール判定を無効にするフラグ
    let scrollPercent = 0; // スクロールの進捗割合

    virtualScroll.addEventListener("scroll", () => {
      if (isScrollDisabled) {
        return; // スクロール判定が無効な場合は処理をスキップ
      }

      const maxScroll = virtualScroll.scrollHeight - virtualScroll.clientHeight;
      const currentScroll = virtualScroll.scrollTop;
      scrollPercent = Math.min(currentScroll / maxScroll, 1);
      
      // スクロールが100%に達した場合
      if (scrollPercent >= 1) {
        // スクロール判定を無効にする
        isScrollDisabled = true;
        
        // 3秒後にスクロール判定を再び有効にする
        setTimeout(() => {
          isScrollDisabled = false;
          console.log("Scroll detection re-enabled after 3 seconds");
        }, 0); // 3000ミリ秒 = 3秒

        // 必要な処理（例: 固定解除、テキスト表示など）
        vrmContainer.classList.remove("fixed");
        vrmContainer.classList.add("normal");
        animatedText.style.display = "block";

        // グリッチ効果の量をスクロールに応じて更新
        glitchPass.uniforms.amount.value = 0.2 + (1 - scrollPercent) * 0.6;

        return; // 100%に達した場合は以降の処理をスキップ
      }

      // それ以外のスクロール判定
      if (scrollPercent >= 0.7) {
        vrmContainer.classList.remove("fixed");
        vrmContainer.classList.add("normal");
        animatedText.style.display = "block";
      } else {
        vrmContainer.classList.remove("normal");
        vrmContainer.classList.add("fixed");
        animatedText.style.display = "none";
      }

      // グリッチ効果の量をスクロールに応じて更新
      glitchPass.uniforms.amount.value = 0.2 + (1 - scrollPercent) * 0.6;
    });

    // ▼ GLTFLoader のセットアップ (VRM + VRMA 両方使えるようにプラグイン登録)
    const loader = new GLTFLoader();
    loader.register((parser) => new VRMLoaderPlugin(parser));
    loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

    let currentVrm: VRM | null = null;
    let currentMixer: THREE.AnimationMixer | null = null;

    // VRM 読み込み
    // （VRMA 読み込みはこの後に続けて行う）
    try {
      const gltf = await new Promise<GLTF>((resolve, reject) => {
        loader.load(
          "/models/demo.vrm",
          resolve,
          (progress) => console.log("Loading progress:", (progress.loaded / progress.total) * 100 + "%"),
          reject
        );
      });

      const vrm = gltf.userData.vrm as VRM;
      if (vrm) {
        currentVrm = vrm;
        scene.add(vrm.scene);

        vrm.scene.position.set(0, 0, 0);
        vrm.scene.rotation.y = Math.PI;

        // とりあえず表情テスト
        if (vrm.expressionManager) {
          vrm.expressionManager.setValue("blink", 1.0);
          vrm.expressionManager.update();
        }
      }
    } catch (error) {
      console.error("Error loading VRM model:", error);
    }

    // ▼ VRMA を読み込んで、アニメーションを適用
    //   VRM が読み込めている前提で実行 (async/awaitで順番保証)
    try {
      const gltf2 = await new Promise<GLTF>((resolve, reject) => {
        loader.load(
          "/animations/listen.vrma", // ここを実際のファイルパスに置き換える
          resolve,
          (progress) => console.log("Loading VRMA progress:", (progress.loaded / progress.total) * 100 + "%"),
          reject
        );
      });

      // .vrma ファイルでは userData.vrmAnimations に配列が入る
      const vrmAnimations = gltf2.userData.vrmAnimations;
      if (vrmAnimations && vrmAnimations.length > 0 && currentVrm) {
        // 最初のアニメーションを仮に使う例
        const vrma = vrmAnimations[0];

        // Mixer の作成
        currentMixer = new THREE.AnimationMixer(currentVrm.scene);

        // アニメーションクリップを生成
        const clip = createVRMAnimationClip(vrma, currentVrm);

        // ループなど調整したい場合は下記のように設定
        // clip.loop = THREE.LoopRepeat; // ループ再生したい場合
        // clip.clampWhenFinished = true;

        // 再生開始
        const action = currentMixer.clipAction(clip);
        action.play();

        console.log("VRMA animation loaded and playing");
      }
    } catch (error) {
      console.error("Error loading VRMA animation:", error);
    }

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // ▼ カメラ手ブレ効果の実装開始
      // 時間に基づいて揺れを計算
      const elapsed = clock.elapsedTime * shakeSpeed;

      // サイン波とコサイン波を使用して滑らかな揺れを作成
      const shakeX = Math.sin(elapsed * 0.7) * shakeIntensity;
      const shakeY = Math.cos(elapsed * 0.5) * shakeIntensity;
      const shakeZ = Math.sin(elapsed * 0.3) * shakeIntensity;

      // 基本回転に揺れを加える
      camera.rotation.x = baseCameraRotation.x + shakeY;
      camera.rotation.y = baseCameraRotation.y + shakeX;
      camera.rotation.z = baseCameraRotation.z + shakeZ;
      // ▼ カメラ手ブレ効果の実装終了

      // VRM の表情連動（スクロール連動）など
      if (currentVrm) {
        if (currentVrm.expressionManager) {
          currentVrm.expressionManager.setValue("blink", 1.0 - scrollPercent);
          currentVrm.expressionManager.update();
        }

        // ライト強度をスクロールに応じて変化
        directionalLight.intensity = 1.0 + scrollPercent * 0.8;
        ambientLight.intensity = 0.5 + scrollPercent * 0.4;

        // VRM のアップデート
        currentVrm.update(delta);
      }

      // ▼ VRMA 再生用ミキサー更新
      if (currentMixer) {
        currentMixer.update(delta);
      }

      // グリッチシェーダーの time を更新しつつレンダリング
      glitchPass.uniforms.time.value += delta;
      composer.render();
    }

    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Forcefully remove focus from the virtual-scroll div after initialization
    if (virtualScroll) {
      // Use a small timeout to ensure all rendering is complete
      setTimeout(() => {
        virtualScroll.blur();
        console.log("virtual-scroll blur executed");
      }, 100); // Adjust the timeout duration as needed
    }
  };

  document.addEventListener("DOMContentLoaded", main);
</script>

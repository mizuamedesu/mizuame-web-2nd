---
// src/pages/slides/[slug].astro
import { readdir } from 'fs/promises';
import path from 'path';
import Layout from '../../layouts/SlideLayout.astro';

// 静的ルート生成: public/slides フォルダからPDFファイル一覧を取得
export async function getStaticPaths() {
  const slidesDir = path.join(process.cwd(), 'public/slides');
  
  try {
    const files = await readdir(slidesDir);
    const pdfFiles = files.filter(file => file.endsWith('.pdf'));
    
    return pdfFiles.map(file => ({
      params: { 
        slug: file.replace('.pdf', '') 
      },
      props: {
        filename: file,
        title: file.replace('.pdf', '').replace(/-/g, ' ')
      }
    }));
  } catch (error) {
    console.log('slides フォルダが存在しません');
    return [];
  }
}

const { slug } = Astro.params;
const { filename, title } = Astro.props;
---

<Layout title={`スライド: ${title}`} description={`${title}のスライド表示`}>
  <main>
    <div class="slide-header">
      <a href="/slides" class="back-link">← スライド一覧に戻る</a>
      <h1>{title}</h1>
    </div>
    
    <div class="slide-controls">
      <button id="prev-page" disabled>前のページ</button>
      <span id="page-info">
        <span id="current-page">1</span> / <span id="total-pages">-</span>
      </span>
      <button id="next-page" disabled>次のページ</button>
      <div class="zoom-controls">
        <button id="zoom-out">−</button>
        <span id="zoom-level">100%</span>
        <button id="zoom-in">+</button>
      </div>
    </div>
    
    <div class="slide-container">
      <div id="loading">スライドを読み込み中...</div>
      <canvas id="pdf-canvas"></canvas>
    </div>
  </main>
</Layout>

<style>
  .slide-header {
    margin-bottom: 2rem;
  }
  
  .back-link {
    display: inline-block;
    margin-bottom: 1rem;
    color: #0066cc;
    text-decoration: none;
  }
  
  .back-link:hover {
    text-decoration: underline;
  }
  
  .slide-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
    flex-wrap: wrap;
  }
  
  .slide-controls button {
    padding: 0.5rem 1rem;
    border: 1px solid #ddd;
    background: #fff;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
  }
  
  .slide-controls button:hover:not(:disabled) {
    background: #f0f0f0;
  }
  
  .slide-controls button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .zoom-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-left: auto;
  }
  
  #page-info {
    font-weight: bold;
    min-width: 80px;
    text-align: center;
  }
  
  #zoom-level {
    min-width: 50px;
    text-align: center;
    font-size: 0.9rem;
  }
  
  .slide-container {
    text-align: center;
    overflow: auto;
  }
  
  #pdf-canvas {
    max-width: 100%;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    background: white;
  }
  
  #loading {
    color: #666;
    font-size: 1.1rem;
    padding: 2rem;
  }
  
  .error {
    color: #cc0000;
    font-size: 1.1rem;
    padding: 2rem;
  }
</style>

<script define:vars={{ slug, filename }}>
  document.addEventListener('DOMContentLoaded', async () => {
    // PDF.js はCDNから読み込み済み（グローバルのpdfjsLibを使用）
    if (typeof pdfjsLib === 'undefined') {
      console.error('PDF.js が読み込まれていません');
      return;
    }
    
    // PDF.js worker の設定
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    // PDF.js worker の設定
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  
  class SlideViewer {
    constructor() {
      this.pdf = null;
      this.currentPage = 1;
      this.totalPages = 0;
      this.scale = 1.0;
      
      const canvas = document.getElementById('pdf-canvas');
      if (!canvas || !(canvas instanceof HTMLCanvasElement)) {
        console.error('Canvas要素が見つかりません');
        return;
      }
      
      this.canvas = canvas;
      const context = this.canvas.getContext('2d');
      if (!context) {
        console.error('Canvas context の取得に失敗しました');
        return;
      }
      this.context = context;
      
      this.initializeElements();
      this.bindEvents();
      this.loadPDF();
    }
    
    initializeElements() {
      this.prevButton = document.getElementById('prev-page');
      this.nextButton = document.getElementById('next-page');
      this.currentPageSpan = document.getElementById('current-page');
      this.totalPagesSpan = document.getElementById('total-pages');
      this.zoomInButton = document.getElementById('zoom-in');
      this.zoomOutButton = document.getElementById('zoom-out');
      this.zoomLevelSpan = document.getElementById('zoom-level');
      this.loadingDiv = document.getElementById('loading');
      
      // null チェック
      if (!this.prevButton || !this.nextButton || !this.currentPageSpan || 
          !this.totalPagesSpan || !this.zoomInButton || !this.zoomOutButton || 
          !this.zoomLevelSpan || !this.loadingDiv) {
        console.error('必要なUI要素が見つかりません');
        return;
      }
    }
    
    bindEvents() {
      if (!this.prevButton || !this.nextButton || !this.zoomInButton || !this.zoomOutButton) {
        console.error('ボタン要素が見つかりません');
        return;
      }
      
      this.prevButton.addEventListener('click', () => this.goToPreviousPage());
      this.nextButton.addEventListener('click', () => this.goToNextPage());
      this.zoomInButton.addEventListener('click', () => this.zoomIn());
      this.zoomOutButton.addEventListener('click', () => this.zoomOut());
      
      // キーボードショートカット
      document.addEventListener('keydown', (e) => {
        switch(e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            this.goToPreviousPage();
            break;
          case 'ArrowRight':
            e.preventDefault();
            this.goToNextPage();
            break;
          case '+':
          case '=':
            e.preventDefault();
            this.zoomIn();
            break;
          case '-':
            e.preventDefault();
            this.zoomOut();
            break;
        }
      });
    }
    
    async loadPDF() {
      if (!this.totalPagesSpan || !this.loadingDiv || !this.canvas) {
        console.error('必要な要素が見つかりません');
        return;
      }
      
      try {
        this.pdf = await pdfjsLib.getDocument(`/slides/${filename}`).promise;
        this.totalPages = this.pdf.numPages;
        this.totalPagesSpan.textContent = this.totalPages.toString();
        
        this.loadingDiv.style.display = 'none';
        this.canvas.style.display = 'block';
        
        await this.renderPage();
        this.updateControls();
        
      } catch (error) {
        console.error('PDF読み込みエラー:', error);
        this.loadingDiv.innerHTML = '<div class="error">スライドの読み込みに失敗しました</div>';
      }
    }
    
    async renderPage() {
  if (!this.pdf || !this.canvas || !this.context) {
    console.error('PDF、Canvas、または Context が利用できません');
    return;
  }
  
  const page = await this.pdf.getPage(this.currentPage);
  
  // コンテナの利用可能サイズを取得
  const container = this.canvas.parentElement;
  const containerWidth = container.clientWidth; // paddingなしなので引かない
  const containerHeight = window.innerHeight * 0.7; // 画面の70%
  
  // PDFページの元のサイズを取得
  const originalViewport = page.getViewport({ scale: 1.0 });
  
  // コンテナに収まるスケールを計算
  const scaleX = containerWidth / originalViewport.width;
  const scaleY = containerHeight / originalViewport.height;
  const autoScale = Math.min(scaleX, scaleY);
  
  // ユーザーのズーム操作を考慮した最終スケール
  const finalScale = autoScale * this.scale;
  
  const viewport = page.getViewport({ scale: finalScale });
  
  this.canvas.height = viewport.height;
  this.canvas.width = viewport.width;
  
  await page.render({
    canvasContext: this.context,
    viewport: viewport
  }).promise;
}
    
    updateControls() {
      if (this.currentPageSpan) {
        this.currentPageSpan.textContent = this.currentPage.toString();
      }
      if (this.prevButton) {
        this.prevButton.disabled = this.currentPage <= 1;
      }
      if (this.nextButton) {
        this.nextButton.disabled = this.currentPage >= this.totalPages;
      }
      if (this.zoomLevelSpan) {
        this.zoomLevelSpan.textContent = Math.round(this.scale * 100) + '%';
      }
    }
    
    async goToPreviousPage() {
      if (this.currentPage > 1) {
        this.currentPage--;
        await this.renderPage();
        this.updateControls();
      }
    }
    
    async goToNextPage() {
      if (this.currentPage < this.totalPages) {
        this.currentPage++;
        await this.renderPage();
        this.updateControls();
      }
    }
    
    async zoomIn() {
      this.scale = Math.min(this.scale * 1.25, 3.0);
      await this.renderPage();
      this.updateControls();
    }
    
    async zoomOut() {
      this.scale = Math.max(this.scale * 0.8, 0.5);
      await this.renderPage();
      this.updateControls();
    }
  }
  
  // ページ読み込み完了後にビューアーを初期化
  new SlideViewer();
  });
</script>